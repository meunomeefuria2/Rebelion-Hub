local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- ===== Functions to get closest player =====
local AIMBOT_MAX_DISTANCE = 150 -- Maximum distance for aimbot to activate

local function getClosestGuard()
    local closest = nil
    local shortestDistance = math.huge
    
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return nil
    end
    
    local myPos = LocalPlayer.Character.HumanoidRootPart.Position

    for _, player in pairs(Players:GetPlayers()) do
        -- Always check current team status
        if player.Team and player.Team.Name == "Guard"
            and player.Character
            and player.Character:FindFirstChild("Head")
            and player.Character:FindFirstChild("Humanoid")
            and player.Character.Humanoid.Health > 0
        then
            local dist = (player.Character.Head.Position - myPos).Magnitude
            if dist < shortestDistance and dist <= AIMBOT_MAX_DISTANCE then
                shortestDistance = dist
                closest = player
            end
        end
    end

    return closest
end

local function getClosestPlayer()
    local closest = nil
    local shortestDistance = math.huge
    
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return nil
    end

    local myPos = LocalPlayer.Character.HumanoidRootPart.Position

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer
            and player.Character
            and player.Character:FindFirstChild("Head")
            and player.Character:FindFirstChild("Humanoid")
            and player.Character.Humanoid.Health > 0
        then
            local dist = (player.Character.Head.Position - myPos).Magnitude
            if dist < shortestDistance and dist <= AIMBOT_MAX_DISTANCE then
                shortestDistance = dist
                closest = player
            end
        end
    end

    return closest
end

local function getClosestFrontman()
    local closest = nil
    local shortestDistance = math.huge
    
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return nil
    end
    
    local myPos = LocalPlayer.Character.HumanoidRootPart.Position

    for _, player in pairs(Players:GetPlayers()) do
        -- Always check current team status
        if player.Team and player.Team.Name == "Front man"
            and player.Character
            and player.Character:FindFirstChild("Head")
            and player.Character:FindFirstChild("Humanoid")
            and player.Character.Humanoid.Health > 0
        then
            local dist = (player.Character.Head.Position - myPos).Magnitude
            if dist < shortestDistance and dist <= AIMBOT_MAX_DISTANCE then
                shortestDistance = dist
                closest = player
            end
        end
    end

    return closest
end

-- ===== ESP Functions =====
local ESP_Boxes = {}

local function createESP(player, color)
    if player.Character and player.Character:FindFirstChild("Head") then
        local head = player.Character.Head

        local billboard = Instance.new("BillboardGui")
        billboard.Name = "ESPBox"
        billboard.Adornee = head
        billboard.Size = UDim2.new(0, 120, 0, 50)
        billboard.AlwaysOnTop = true

        local frame = Instance.new("Frame")
        frame.BackgroundColor3 = color
        frame.BorderSizePixel = 0
        frame.BackgroundTransparency = 0.3
        frame.Size = UDim2.fromScale(1, 1)
        frame.Parent = billboard

        local label = Instance.new("TextLabel")
        label.Size = UDim2.fromScale(1, 1)
        label.BackgroundTransparency = 1
        label.TextColor3 = Color3.fromRGB(255, 255, 255)
        label.TextStrokeTransparency = 0
        label.Font = Enum.Font.SourceSansBold
        label.TextScaled = true
        -- Always get current team name
        local currentTeamName = (player.Team and player.Team.Name) or "NoTeam"
        label.Text = player.Name .. " (" .. currentTeamName .. ")"
        label.Parent = billboard

        -- Protection against errors when adding to CoreGui
        local success, err = pcall(function()
            billboard.Parent = game.CoreGui
        end)
        
        if not success then
            billboard.Parent = LocalPlayer.PlayerGui
        end
        
        ESP_Boxes[player] = billboard
    end
end

local function removeESP(player)
    if ESP_Boxes[player] then
        ESP_Boxes[player]:Destroy()
        ESP_Boxes[player] = nil
    end
end

local function updateESP(filter)
    -- Remove ESP from players that no longer exist
    for player, _ in pairs(ESP_Boxes) do
        if not Players:FindFirstChild(player.Name) then
            removeESP(player)
        end
    end
    
    -- First, remove all existing ESP to refresh
    for player, _ in pairs(ESP_Boxes) do
        removeESP(player)
    end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer
            and player.Character
            and player.Character:FindFirstChild("Head")
            and player.Character:FindFirstChild("Humanoid")
            and player.Character.Humanoid.Health > 0
        then
            local shouldShow = false
            local color = Color3.fromRGB(0, 255, 0) -- Default green
            
            if filter == "Guard" then
                if player.Team and player.Team.Name == "Guard" then
                    shouldShow = true
                    color = Color3.fromRGB(255, 0, 0) -- Red for guards
                end
            elseif filter == "Frontman" then
                if player.Team and player.Team.Name == "Front man" then
                    shouldShow = true
                    color = Color3.fromRGB(255, 165, 0) -- Orange for Front man
                end
            elseif filter == "Player" then
                shouldShow = true
                if player.Team and player.Team.Name == "Guard" then
                    color = Color3.fromRGB(255, 0, 0) -- Red for guards
                elseif player.Team and player.Team.Name == "Front man" then
                    color = Color3.fromRGB(255, 165, 0) -- Orange for Front man
                else
                    color = Color3.fromRGB(0, 255, 0) -- Green for other players
                end
            end
            
            if shouldShow then
                createESP(player, color)
            end
        end
    end
end

-- ===== OrionLib =====
local OrionLib = loadstring(game:HttpGet(('https://raw.githubusercontent.com/jensonhirst/Orion/main/source')))()

local Window = OrionLib:MakeWindow({
    Name = "Rebelion-HUB", 
    HidePremium = false, 
    SaveConfig = true, 
    ConfigFolder = "RebelionConfig"
})

local Tab = Window:MakeTab({
    Name = "Main",
    Icon = "rbxassetid://4483345998",
    PremiumOnly = false
})

OrionLib:MakeNotification({
    Name = "Success!",
    Content = "Thanks for executing my script!",
    Image = "rbxassetid://4483345998",
    Time = 5
})

-- ===== Toggles =====

-- AIMBOT TOGGLES
local AimbotGuardConnection = nil
Tab:AddToggle({
    Name = "Aimbot Guard",
    Default = false,
    Callback = function(state)
        if state then
            AimbotGuardConnection = RunService.RenderStepped:Connect(function()
                local closestGuard = getClosestGuard()
                if closestGuard and closestGuard.Character and closestGuard.Character:FindFirstChild("Head") then
                    local targetPos = closestGuard.Character.Head.Position
                    local cameraPos = Camera.CFrame.Position
                    local newCFrame = CFrame.new(cameraPos, targetPos)
                    Camera.CFrame = Camera.CFrame:Lerp(newCFrame, 0.2)
                end
            end)
        else
            if AimbotGuardConnection then
                AimbotGuardConnection:Disconnect()
                AimbotGuardConnection = nil
            end
        end
    end
})

local AimbotPlayerConnection = nil
Tab:AddToggle({
    Name = "Aimbot Player",
    Default = false,
    Callback = function(state)
        if state then
            AimbotPlayerConnection = RunService.RenderStepped:Connect(function()
                local closestPlayer = getClosestPlayer()
                if closestPlayer and closestPlayer.Character and closestPlayer.Character:FindFirstChild("Head") then
                    local targetPos = closestPlayer.Character.Head.Position
                    local cameraPos = Camera.CFrame.Position
                    local newCFrame = CFrame.new(cameraPos, targetPos)
                    Camera.CFrame = Camera.CFrame:Lerp(newCFrame, 0.2)
                end
            end)
        else
            if AimbotPlayerConnection then
                AimbotPlayerConnection:Disconnect()
                AimbotPlayerConnection = nil
            end
        end
    end
})

local AimbotFrontmanConnection = nil
Tab:AddToggle({
    Name = "Aimbot Front man",
    Default = false,
    Callback = function(state)
        if state then
            AimbotFrontmanConnection = RunService.RenderStepped:Connect(function()
                local closestFrontman = getClosestFrontman()
                if closestFrontman and closestFrontman.Character and closestFrontman.Character:FindFirstChild("Head") then
                    local targetPos = closestFrontman.Character.Head.Position
                    local cameraPos = Camera.CFrame.Position
                    local newCFrame = CFrame.new(cameraPos, targetPos)
                    Camera.CFrame = Camera.CFrame:Lerp(newCFrame, 0.2)
                end
            end)
        else
            if AimbotFrontmanConnection then
                AimbotFrontmanConnection:Disconnect()
                AimbotFrontmanConnection = nil
            end
        end
    end
})

-- ESP TOGGLES
local ESPGuardConnection = nil
Tab:AddToggle({
    Name = "ESP Guards",
    Default = false,
    Callback = function(state)
        if state then
            updateESP("Guard")
            ESPGuardConnection = RunService.RenderStepped:Connect(function()
                updateESP("Guard")
            end)
        else
            if ESPGuardConnection then
                ESPGuardConnection:Disconnect()
                ESPGuardConnection = nil
            end
            -- Remove ESP of guards when disabling
            for player, _ in pairs(ESP_Boxes) do
                if player.Team and player.Team.Name == "Guard" then
                    removeESP(player)
                end
            end
        end
    end
})

local ESPPlayerConnection = nil
Tab:AddToggle({
    Name = "ESP Players",
    Default = false,
    Callback = function(state)
        if state then
            updateESP("Player")
            ESPPlayerConnection = RunService.RenderStepped:Connect(function()
                updateESP("Player")
            end)
        else
            if ESPPlayerConnection then
                ESPPlayerConnection:Disconnect()
                ESPPlayerConnection = nil
            end
            -- Remove all ESP when disabling
            for player, _ in pairs(ESP_Boxes) do
                removeESP(player)
            end
        end
    end
})

local ESPFrontmanConnection = nil
Tab:AddToggle({
    Name = "ESP Front man",
    Default = false,
    Callback = function(state)
        if state then
            updateESP("Frontman")
            ESPFrontmanConnection = RunService.RenderStepped:Connect(function()
                updateESP("Frontman")
            end)
        else
            if ESPFrontmanConnection then
                ESPFrontmanConnection:Disconnect()
                ESPFrontmanConnection = nil
            end
            -- Remove ESP of Front man when disabling
            for player, _ in pairs(ESP_Boxes) do
                if player.Team and player.Team.Name == "Front man" then
                    removeESP(player)
                end
            end
        end
    end
})

-- ===== Noclip Toggle =====
local NoclipConnection = nil
Tab:AddToggle({
    Name = "Noclip",
    Default = false,
    Callback = function(state)
        if state then
            NoclipConnection = RunService.Stepped:Connect(function()
                local character = LocalPlayer.Character
                if character then
                    for _, part in pairs(character:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
            end)
        else
            if NoclipConnection then
                NoclipConnection:Disconnect()
                NoclipConnection = nil
            end
            -- Reactivate collision when disabling
            local character = LocalPlayer.Character
            if character then
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                        part.CanCollide = true
                    end
                end
            end
        end
    end
})

-- ===== God Mode Toggle =====
local GodModeConnection = nil
Tab:AddToggle({
    Name = "God Mode (Experimental - May not work most times)",
    Default = false,
    Callback = function(state)
        if state then
            GodModeConnection = RunService.Heartbeat:Connect(function()
                local character = LocalPlayer.Character
                if character and character:FindFirstChild("Humanoid") then
                    local humanoid = character.Humanoid
                    
                    -- Method 1: Keep health at max
                    humanoid.MaxHealth = math.huge
                    humanoid.Health = math.huge
                    
                    -- Method 2: Prevent death
                    if humanoid.Health <= 0 then
                        humanoid.Health = math.huge
                    end
                    
                    -- Method 3: Remove damage-dealing objects
                    for _, obj in pairs(character:GetDescendants()) do
                        if obj:IsA("Fire") or obj:IsA("Smoke") then
                            obj:Destroy()
                        end
                    end
                    
                    -- Method 4: Prevent specific damage types
                    humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
                    humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
                    humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
                end
                
                -- Method 5: Character-level protection
                if LocalPlayer.Character then
                    LocalPlayer.Character:SetAttribute("Invincible", true)
                    
                    -- Prevent character deletion
                    for _, part in pairs(LocalPlayer.Character:GetChildren()) do
                        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                            part:SetAttribute("Protected", true)
                        end
                    end
                end
            end)
            
            -- Additional protection when character spawns
            local function protectNewCharacter(character)
                if character then
                    wait(1) -- Wait for character to fully load
                    local humanoid = character:WaitForChild("Humanoid", 5)
                    if humanoid then
                        humanoid.MaxHealth = math.huge
                        humanoid.Health = math.huge
                        humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
                    end
                end
            end
            
            -- Connect to character spawning
            if LocalPlayer.Character then
                protectNewCharacter(LocalPlayer.Character)
            end
            LocalPlayer.CharacterAdded:Connect(protectNewCharacter)
            
        else
            if GodModeConnection then
                GodModeConnection:Disconnect()
                GodModeConnection = nil
            end
            
            -- Reset to normal when disabling
            local character = LocalPlayer.Character
            if character and character:FindFirstChild("Humanoid") then
                local humanoid = character.Humanoid
                humanoid.MaxHealth = 100
                humanoid.Health = 100
                humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, true)
                humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, true)
                humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, true)
            end
            
            if LocalPlayer.Character then
                LocalPlayer.Character:SetAttribute("Invincible", nil)
                for _, part in pairs(LocalPlayer.Character:GetChildren()) do
                    if part:IsA("BasePart") then
                        part:SetAttribute("Protected", nil)
                    end
                end
            end
        end
    end
})

-- ===== Hitbox Expander Toggle =====
local HitboxConnection = nil
local originalSizes = {}

Tab:AddToggle({
    Name = "Expand Hitboxes (Enemy Players)",
    Default = false,
    Callback = function(state)
        if state then
            HitboxConnection = RunService.Heartbeat:Connect(function()
                for _, player in pairs(Players:GetPlayers()) do
                    if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                        local hrp = player.Character.HumanoidRootPart
                        -- Store original size if not stored yet
                        if not originalSizes[hrp] then
                            originalSizes[hrp] = hrp.Size
                        end
                        -- Expand HumanoidRootPart hitbox significantly
                        hrp.Size = Vector3.new(8, 8, 8)
                        hrp.Transparency = 0 -- Keep it invisible like normal
                        hrp.CanCollide = false
                    end
                end
            end)
        else
            if HitboxConnection then
                HitboxConnection:Disconnect()
                HitboxConnection = nil
            end
            -- Restore original hitboxes
            for hrp, originalSize in pairs(originalSizes) do
                if hrp and hrp.Parent then
                    hrp.Size = originalSize
                    hrp.Transparency = 1 -- Back to invisible
                    hrp.CanCollide = false -- HumanoidRootPart should never collide
                end
            end
            originalSizes = {}
        end
    end
})

-- ===== Fling Toggle =====
local FlingConnection = nil
local FlingForce = 50000 -- Adjust this value for more/less fling power

Tab:AddToggle({
    Name = "Fling Players (Touch to Launch)",
    Default = false,
    Callback = function(state)
        if state then
            FlingConnection = RunService.Heartbeat:Connect(function()
                local character = LocalPlayer.Character
                if character and character:FindFirstChild("HumanoidRootPart") then
                    local myHRP = character.HumanoidRootPart
                    
                    for _, player in pairs(Players:GetPlayers()) do
                        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                            local theirHRP = player.Character.HumanoidRootPart
                            local distance = (myHRP.Position - theirHRP.Position).Magnitude
                            
                            -- If close enough to touch
                            if distance <= 8 then
                                -- Create fling force on THEIR character, not yours
                                local bodyVelocity = theirHRP:FindFirstChild("FlingForce")
                                if not bodyVelocity then
                                    bodyVelocity = Instance.new("BodyVelocity")
                                    bodyVelocity.Name = "FlingForce"
                                    bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                                    bodyVelocity.Parent = theirHRP
                                    
                                    -- Calculate fling direction (away from you and upward)
                                    local direction = (theirHRP.Position - myHRP.Position).Unit
                                    direction = direction + Vector3.new(0, 2, 0) -- Strong upward force
                                    bodyVelocity.Velocity = direction * FlingForce
                                    
                                    -- Remove the force after a short time
                                    game:GetService("Debris"):AddItem(bodyVelocity, 1)
                                    
                                    -- Also disable their character's physics temporarily
                                    if player.Character:FindFirstChild("Humanoid") then
                                        player.Character.Humanoid.PlatformStand = true
                                        spawn(function()
                                            wait(2)
                                            if player.Character and player.Character:FindFirstChild("Humanoid") then
                                                player.Character.Humanoid.PlatformStand = false
                                            end
                                        end)
                                    end
                                end
                            end
                        end
                    end
                end
            end)
        else
            if FlingConnection then
                FlingConnection:Disconnect()
                FlingConnection = nil
            end
            -- Remove any remaining fling forces and restore physics
            for _, player in pairs(Players:GetPlayers()) do
                if player.Character then
                    if player.Character:FindFirstChild("HumanoidRootPart") then
                        local flingForce = player.Character.HumanoidRootPart:FindFirstChild("FlingForce")
                        if flingForce then
                            flingForce:Destroy()
                        end
                    end
                    if player.Character:FindFirstChild("Humanoid") then
                        player.Character.Humanoid.PlatformStand = false
                    end
                end
            end
        end
    end
})

-- ===== Be The Front Man Button =====
Tab:AddButton({
    Name = "Be The Front Man",
    Callback = function()
        -- Try to change team to Front man
        local success1 = pcall(function()
            if game.Teams and game.Teams:FindFirstChild("Front man") then
                LocalPlayer.Team = game.Teams["Front man"]
                print("Team changed to Front man!")
            else
                -- Try alternative team names
                for _, team in pairs(game.Teams:GetChildren()) do
                    if string.lower(team.Name):find("front") or string.lower(team.Name):find("man") then
                        LocalPlayer.Team = team
                        print("Team changed to: " .. team.Name)
                        break
                    end
                end
            end
        end)
        
        if not success1 then
            print("Failed to change team - trying alternative method")
        end
        
        -- Try to reset/kill character
        local success2 = pcall(function()
            if LocalPlayer.Character then
                if LocalPlayer.Character:FindFirstChild("Humanoid") then
                    LocalPlayer.Character.Humanoid.Health = 0
                    print("Character reset!")
                elseif LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    LocalPlayer.Character.HumanoidRootPart:Destroy()
                    print("Character destroyed!")
                else
                    LocalPlayer.Character:Destroy()
                    print("Character removed!")
                end
            else
                -- Force respawn if no character
                LocalPlayer:LoadCharacter()
                print("Character respawned!")
            end
        end)
        
        if not success2 then
            print("Failed to reset character")
        end
        
        -- Notification
        OrionLib:MakeNotification({
            Name = "Front Man Mode",
            Content = "Attempting to become Front Man...",
            Image = "rbxassetid://4483345998",
            Time = 3
        })
    end
})

-- ===== The Party Toggle (Epilepsy Warning) =====
local PartyConnection = nil
local PartySound = nil
local PartyGui = nil

Tab:AddToggle({
    Name = "The Party (Epilepsy Warning)",
    Default = false,
    Callback = function(state)
        if state then
            -- Create sound
            PartySound = Instance.new("Sound")
            PartySound.SoundId = "rbxassetid://114376757380093"
            PartySound.Volume = 0.5
            PartySound.Looped = true
            PartySound.Parent = workspace
            PartySound:Play()
            
            -- Create flashing screen GUI
            PartyGui = Instance.new("ScreenGui")
            PartyGui.Name = "PartyEffects"
            PartyGui.Parent = LocalPlayer.PlayerGui
            
            local flashFrame = Instance.new("Frame")
            flashFrame.Name = "FlashFrame"
            flashFrame.Size = UDim2.fromScale(1, 1)
            flashFrame.Position = UDim2.fromScale(0, 0)
            flashFrame.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
            flashFrame.BackgroundTransparency = 0.5
            flashFrame.Parent = PartyGui
            
            -- Start party effects
            local flashColors = {
                Color3.fromRGB(255, 0, 0),    -- Red
                Color3.fromRGB(0, 0, 0),      -- Black
                Color3.fromRGB(255, 255, 255), -- White
                Color3.fromRGB(255, 0, 255),   -- Magenta
                Color3.fromRGB(0, 255, 0),     -- Green
                Color3.fromRGB(0, 0, 255),     -- Blue
                Color3.fromRGB(255, 255, 0)    -- Yellow
            }
            
            PartyConnection = RunService.Heartbeat:Connect(function()
                if flashFrame then
                    -- Flash colors rapidly
                    local randomColor = flashColors[math.random(1, #flashColors)]
                    flashFrame.BackgroundColor3 = randomColor
                    flashFrame.BackgroundTransparency = math.random(0, 80) / 100
                end
                
                -- Camera distortion
                if Camera then
                    local randomOffset = Vector3.new(
                        math.random(-5, 5),
                        math.random(-5, 5),
                        math.random(-5, 5)
                    )
                    local randomRotation = CFrame.Angles(
                        math.rad(math.random(-10, 10)),
                        math.rad(math.random(-10, 10)),
                        math.rad(math.random(-10, 10))
                    )
                    
                    -- Apply distortion to camera
                    local originalCFrame = Camera.CFrame
                    Camera.CFrame = originalCFrame * randomRotation + randomOffset
                end
            end)
            
        else
            -- Stop party effects
            if PartyConnection then
                PartyConnection:Disconnect()
                PartyConnection = nil
            end
            
            if PartySound then
                PartySound:Stop()
                PartySound:Destroy()
                PartySound = nil
            end
            
            if PartyGui then
                PartyGui:Destroy()
                PartyGui = nil
            end
            
            -- Reset camera to normal (attempt)
            if Camera and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                Camera.CameraSubject = LocalPlayer.Character.Humanoid
                Camera.CameraType = Enum.CameraType.Custom
            end
        end
    end
})

-- ===== Cleanup when player leaves =====
Players.PlayerRemoving:Connect(function(player)
    removeESP(player)
    -- Clear target references when players leave
    if currentGuardTarget == player then
        currentGuardTarget = nil
    end
    if currentPlayerTarget == player then
        currentPlayerTarget = nil
    end
    if currentFrontmanTarget == player then
        currentFrontmanTarget = nil
    end
end)

-- ===== Monitor team changes =====
Players.PlayerAdded:Connect(function(player)
    player:GetPropertyChangedSignal("Team"):Connect(function()
        -- Small delay to ensure team change is processed
        wait(0.1)
        -- Force refresh ESP for all players when someone changes team
        for existingPlayer, espBox in pairs(ESP_Boxes) do
            if existingPlayer == player then
                removeESP(player)
                break
            end
        end
    end)
end)

-- Monitor team changes for existing players
for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        player:GetPropertyChangedSignal("Team"):Connect(function()
            wait(0.1)
            -- Remove ESP for the player who changed teams
            removeESP(player)
        end)
    end
end

-- ===== Prints =====
print("Rebelion-HUB loaded successfully!")
print("Guards ESP & Aimbot: Loaded")
print("Players ESP & Aimbot: Loaded") 
print("Front man ESP & Aimbot: Loaded")
print("Hitbox Expander: Ready")
print("Fling System: Ready")
print("Party Mode: Ready")

-- Debug function to check teams
spawn(function()
    wait(3)
    print("=== TEAM DEBUG ===")
    for _, player in pairs(Players:GetPlayers()) do
        if player.Team then
            print(player.Name .. " is on team: " .. player.Team.Name)
        else
            print(player.Name .. " has no team")
        end
    end
    print("=== END DEBUG ===")
end)